import { type Compiler } from 'webpack'
import webpack from 'webpack'
import upath from 'upath'
import stringify from 'fast-json-stable-stringify'
import { validateWebpackInjectManifestOptions } from 'workbox-build/build/lib/validate-options'
import type { InjectManifest } from './workbox-webpack-plugin'
import { getManifestEntriesFromCompilation } from './workbox-webpack-plugin/lib/get-manifest-entries-from-compilation'
import { relativeToOutputPath } from './workbox-webpack-plugin/lib/relative-to-output-path'

type InjectManifestProps = InjectManifest['config']
const { RawSource } = webpack.sources || require('webpack-sources')

export interface WorkboxMicroSubAppPluginProps extends InjectManifestProps {

}

const _generatedAssetNames = new Set<string>()

// only emit the manifest for the main app to load.
export class WorkboxMicroSubAppPlugin {
  private alreadyCalled: boolean

  constructor(private config: WorkboxMicroSubAppPluginProps) {
    this.alreadyCalled = false
  }

  propagateWebpackConfig(compiler: webpack.Compiler): void {
    // Because this.config is listed last, properties that are already set
    // there take precedence over derived properties from the compiler.
    this.config = Object.assign(
      {
        mode: compiler.options.mode,
        swDest: `${upath.parse(this.config.swSrc).name}.json`,
      },
      this.config,
    )
  }

  async handleMake(
    compilation: webpack.Compilation,
  ): Promise<void> {
    try {
      this.config = validateWebpackInjectManifestOptions(this.config)
    }
    catch (error) {
      if (error instanceof Error) {
        throw new TypeError(
          `Please check your ${this.constructor.name} plugin `
            + `configuration:\n${error.message}`,
        )
      }
    }

    this.config.swDest = relativeToOutputPath(compilation, this.config.swDest!)
    _generatedAssetNames.add(this.config.swDest)
  }

  async emitManifest(compilation: webpack.Compilation): Promise<void> {
    // See https://github.com/GoogleChrome/workbox/issues/1790
    if (this.alreadyCalled) {
      const warningMessage
          = `${this.constructor.name} has been called `
          + 'multiple times, perhaps due to running webpack in --watch mode. The '
          + 'precache manifest generated after the first call may be inaccurate! '
          + 'Please see https://github.com/GoogleChrome/workbox/issues/1790 for '
          + 'more information.'

      if (
        !compilation.warnings.some(
          warning =>
            warning instanceof Error && warning.message === warningMessage,
        )
      ) {
        compilation.warnings.push(
          new Error(warningMessage) as webpack.WebpackError,
        )
      }
    }
    else {
      this.alreadyCalled = true
    }

    const config = Object.assign({}, this.config)

    // Ensure that we don't precache any of the assets generated by *any*
    // instance of this plugin.

    config.exclude!.push(({ asset }) => _generatedAssetNames.has(asset.name))

    // See https://webpack.js.org/contribute/plugin-patterns/#monitoring-the-watch-graph
    const absoluteSwSrc = upath.resolve(this.config.swSrc)
    compilation.fileDependencies.add(absoluteSwSrc)

    const { sortedEntries } = await getManifestEntriesFromCompilation(
      compilation,
      config,
    )

    const manifestString = stringify(sortedEntries)

    compilation.emitAsset(
      relativeToOutputPath(compilation, config.swDest!),
      new RawSource(Buffer.from(manifestString)),
      {
        // See https://github.com/webpack-contrib/compression-webpack-plugin/issues/218#issuecomment-726196160
        minimized: config.mode === 'production',
      },
    )
  }

  apply(compiler: Compiler): void {
    this.propagateWebpackConfig(compiler)

    compiler.hooks.make.tapPromise(this.constructor.name, compilation =>
      this.handleMake(compilation).catch(
        (error: webpack.WebpackError) => {
          compilation.errors.push(error)
        },
      ),
    )

    // webpack v4/v5 compatibility:
    // https://github.com/webpack/webpack/issues/11425#issuecomment-690387207
    if (webpack.version?.startsWith('4.')) {
      compiler.hooks.emit.tapPromise(this.constructor.name, compilation =>
        this.emitManifest(compilation).catch((error: webpack.WebpackError) => {
          compilation.errors.push(error)
        }),
      )
    }
    else {
      const { PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER } = webpack.Compilation
      // Specifically hook into thisCompilation, as per
      // https://github.com/webpack/webpack/issues/11425#issuecomment-690547848
      compiler.hooks.thisCompilation.tap(
        this.constructor.name,
        (compilation) => {
          compilation.hooks.processAssets.tapPromise(
            {
              name: this.constructor.name,
              // TODO(jeffposnick): This may need to change eventually.
              // See https://github.com/webpack/webpack/issues/11822#issuecomment-726184972
              stage: PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER - 10,
            },
            () =>
              this.emitManifest(compilation).catch(
                (error: webpack.WebpackError) => {
                  compilation.errors.push(error)
                },
              ),
          )
        },
      )
    }
  }
}
